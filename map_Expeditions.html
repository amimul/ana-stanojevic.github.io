<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="initial-scale=1.0, width=device-width" />
    <title>Expeditions Map</title>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.5.0/d3.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
    <script src="http://d3js.org/d3.v4.min.js"></script>
    <link href="https://fonts.googleapis.com/css?family=Abril+Fatface|Yanone+Kaffeesatz:200" rel="stylesheet">

    <!--Map Core-->
    <script type="text/javascript" src="src\map.js"></script>

    <!-- Expeditions -->
    <link rel="stylesheet" type="text/css" href="src\expeditions.css">
    <script type="text/javascript" src="src\expedition.js"></script>

    <link rel="stylesheet" type="text/css" href="src\pack_layout.css">
    <script type="text/javascript" src="src\pack_layout.js"></script>

    <!--Tool-tip-->
    <!--script src="http://labratrevenge.com/d3-tip/javascripts/d3.tip.v0.6.3.js"></script-->
    <!--script src="src\d3-tip\d3-tip.js"></script-->

  </head>

  <body>
    <div id="map-holder"></div>
    <script type="text/javascript">

      d3.selection.prototype.moveToFront = function() {
        return this.each(function(){
        this.parentNode.appendChild(this);
        });
      };

      // Full world map is 2:1 ratio
      // Using 12:5 because we will crop top and bottom of map
      w = 3000;
      h = 1250;
      // variables for catching min and max zoom factors
      var minZoom;
      var maxZoom;
      var expedition_groups = [];
      var expedition_data = new Map();
      let SELECTED_EXP_ID = null;


      // DEFINE FUNCTIONS/OBJECTS
      let projection = map.projection( [0, 15] //center
                                      , [w / (2 * Math.PI)] //scale
                                      , [w / 2, h / 2] ); //translate

      let path = map.path(projection);
      let line = expeditions.geometry.line;
      let closest_point = expeditions.geometry.closestPoint;

      // Create function to apply zoom to countriesGroup
      let zooming = function(d) {
        let _g = d3.select("g");

        _g.selectAll("path")
          .attr("d", path);

        if(expedition_data.size != 0) {
           for(var[id, e_data] of expedition_data) {
             _g.select("#"+id).datum(e_data).attr("d", line);
           }
        }
      }

      function zoomed() {
        zooming();
        t = d3.event.transform;
        countriesGroup
          .attr("transform","translate(" + [t.x, t.y] + ")scale(" + t.k + ")")
        ;
      }
      // Define map zoom behaviour
      var zoom = d3.zoom().on("zoom", zoomed);
      function getTextBox(selection) {
        selection
          .each(function(d) {
            d.bbox = this
              .getBBox();
            })
        ;
      }

      // Function that calculates zoom/pan limits and sets zoom to default value
      function initiateZoom() {
        // Define a "minzoom" whereby the "Countries" is as small possible without leaving white space at top/bottom or sides
        minZoom = Math.max($("#map-holder").width() / w, $("#map-holder").height() / h);
        // set max zoom to a suitable factor of this value
        maxZoom = 20 * minZoom;
        // set extent of zoom to chosen values
        // set translate extent so that panning can't cause map to move out of viewport
        zoom
          .scaleExtent([minZoom, maxZoom])
          .translateExtent([[0, 0], [w, h]])
        ;
        // define X and Y offset for centre of map to be shown in centre of holder
        midX = ($("#map-holder").width() - minZoom * w) / 2;
        midY = ($("#map-holder").height() - minZoom * h) / 2;
        // change zoom transform to min zoom and centre offsets
        svg.call(zoom.transform, d3.zoomIdentity.translate(midX, midY).scale(minZoom));
      }

      // zoom to show a bounding box, with optional additional padding as percentage of box size
      function boxZoom(box, centroid, paddingPerc) {
        minXY = box[0];
        maxXY = box[1];
        // find size of map area defined
        zoomWidth = Math.abs(minXY[0] - maxXY[0]);
        zoomHeight = Math.abs(minXY[1] - maxXY[1]);
        // find midpoint of map area defined
        zoomMidX = centroid[0];
        zoomMidY = centroid[1];
        // increase map area to include padding
        zoomWidth = zoomWidth * (1 + paddingPerc / 100);
        zoomHeight = zoomHeight * (1 + paddingPerc / 100);
        // find scale required for area to fill svg
        maxXscale = $("svg").width() / zoomWidth;
        maxYscale = $("svg").height() / zoomHeight;
        zoomScale = Math.min(maxXscale, maxYscale);
        // handle some edge cases
        // limit to max zoom (handles tiny countries)
        zoomScale = Math.min(zoomScale, maxZoom);
        // limit to min zoom (handles large countries and countries that span the date line)
        zoomScale = Math.max(zoomScale, minZoom);
        // Find screen pixel equivalent once scaled
        offsetX = zoomScale * zoomMidX;
        offsetY = zoomScale * zoomMidY;
        // Find offset to centre, making sure no gap at left or top of holder
        dleft = Math.min(0, $("svg").width() / 2 - offsetX);
        dtop = Math.min(0, $("svg").height() / 2 - offsetY);
        // Make sure no gap at bottom or right of holder
        dleft = Math.max($("svg").width() - w * zoomScale, dleft);
        dtop = Math.max($("svg").height() - h * zoomScale, dtop);
        // set zoom
        svg
          .transition()
          .duration(500)
          .call(
            zoom.transform,
            d3.zoomIdentity.translate(dleft, dtop).scale(zoomScale)
          );
      }
      // on window resize
      $(window).resize(function() {
        // Resize SVG
        svg.attr("width", $("#map-holder").width())
           .attr("height", $("#map-holder").height());
        initiateZoom();
      });

      // create an SVG
      var svg = d3
        .select("#map-holder")
        .append("svg")
        // set to the same size as the "map-holder" div
        .attr("width", $("#map-holder").width())
        .attr("height", $("#map-holder").height())
        // add zoom functionality
        .attr("fill", "pink")
        .call(zoom);

      // get map data
      d3.json(
        "https://raw.githubusercontent.com/andybarefoot/andybarefoot-www/master/maps/mapdata/custom50.json",
        function(json) {
          //Bind data and create one path per GeoJSON feature
          countriesGroup = svg.append("g").attr("id", "map");
          // add a background rectangle
          countriesGroup
            .append("rect")
            .attr("x", 0)
            .attr("y", 0)
            .attr("width", w)
            .attr("height", h);

          // draw a path for each feature/country
          countries = countriesGroup
            .selectAll("path")
            .data(json.features)
            .enter()
            .append("path")
            .attr("d", path)
            .attr("id", function(d, i) {
              return "country" + d.properties.iso_a3;
            })
            .attr("class", "country")
            .on("mouseover", function(d, i) {
                d3.select("#countryLabel" + d.properties.iso_a3).style("display", "block");
            })
            .on("mouseout", function(d, i) {
                d3.select("#countryLabel" + d.properties.iso_a3).style("display", "none");
            })
            // add an onclick action to zoom into clicked country
            .on("click", function(d, i) {
                d3.selectAll(".country").classed("country-on", false);
                d3.select(this).classed("country-on", true);
            boxZoom(path.bounds(d), path.centroid(d), 20);
            });
          // Add a label group to each feature/country. This will contain the country name and a background rectangle
          // Use CSS to have class "countryLabel" initially hidden
          countryLabels = countriesGroup
            .selectAll("g")
            .data(json.features)
            .enter()
            .append("g")
            .attr("class", "countryLabel")
            .attr("id", function(d) {
              return "countryLabel" + d.properties.iso_a3;
            })
            .attr("transform", function(d) {
              return "translate(" + path.centroid(d)[0] + "," + path.centroid(d)[1] + ")";
            })
            .on("mouseover", function(d, i) {
                d3.select(this).style("display", "block");
            })
            .on("mouseout", function(d, i) {
                 d3.select(this).style("display", "none");
            })
            // add an onlcick action to zoom into clicked country
            .on("click", function(d, i) {
                d3.selectAll(".country").classed("country-on", false);
                d3.select("#country" + d.properties.iso_a3).classed("country-on", true);
              boxZoom(path.bounds(d), path.centroid(d), 20);
            });

          countryLabels
            .append("text")
            .attr("class", "countryName")
            .style("text-anchor", "middle")
            .attr("dx", 0)
            .attr("dy", 0)
            .text(function(d) {
              return d.properties.name;
            })
            .call(getTextBox);
          // add a background rectangle the same size as the text
          countryLabels
            .insert("rect", "text")
            .attr("class", "countryLabelBg")
            .attr("transform", function(d) {
              return "translate(" + (d.bbox.x - 2) + "," + d.bbox.y + ")";
            })
            .attr("width", function(d) {
              return d.bbox.width + 4;
            })
            .attr("height", function(d) {
              return d.bbox.height;
            });

          initiateZoom();

          const expedition_files = generate_files(30
             , "data/expeditions/expedition_");

          function multiCsv(files, callback) {
            let files_length = 0;
            for(var i in files) {
              files_length += files[i].length;
            }

            let results = new Map();
            let read_files = 0;

            for(var k in files) {
              for(var i in files[k]) {

                let file_name = files[k][i];
                let ocean = k;
                if(!results.get(ocean)) {
                  results.set(ocean, []);
                }

                d3.text(file_name, function(error, raw) {
                  if(error) { return; }
                  let dsv = d3.dsvFormat(';');
                  let data = dsv.parse(raw);
                  results.get(ocean).push(data);
                  read_files += 1;

                  if(read_files === files_length) {
                    callback(null, results);
                  }
                });
              }
            }
          };

          function cancel_highlight(map) {
            if(SELECTED_EXP_ID == null) {
              return;
            }

            map.selectAll("path#" + SELECTED_EXP_ID)
               .style("stroke", "yellow").style("stroke-width", "1.5");

            const N = expedition_data.get(SELECTED_EXP_ID).length;
            for(var i = 0; i < N; ++i) {
              map.select("circle#ex_point_" + i +"_" + SELECTED_EXP_ID)
                 .style("stroke-width","1");
            }

            SELECTED_EXP_ID = null;
          }

          function highlight(map, exp_id) {
            if(exp_id === SELECTED_EXP_ID) {
              return;
            }

            SELECTED_EXP_ID = exp_id;
            let paths = map.select("path#" + SELECTED_EXP_ID)
               .style("stroke", "white")
               .style("stroke-width","2");

            const N = expedition_data.get(exp_id).length;
            for(var i = 0; i < N; ++i) {
              map.select("circle#ex_point_" + i+"_" + SELECTED_EXP_ID)
                 .style("stroke-width","2");
            }
          }

          const diameter = 250;
          var color = d3.scaleSequential(d3.interpolateMagma)
              .domain([-4, 4]);

          function drawData(data, position, map_svg) {

            let ocean_json_str = JSON.stringify(data);
            let ocean_json = JSON.parse(ocean_json_str);

            var packLayout = d3.pack()
              .size([diameter, diameter]).padding(3);

            let root = d3.hierarchy(ocean_json, function(d){ return d.children; })
            .sum(function(d) {
              return d.total_cd;
            })
            .sort(function(d1, d2){
              return d2.total_cd - d1.total_cd;
            });

            packLayout(root);

            var focus = root,
                nodes = root.descendants(),
                view;

            var g = map_svg.append("g").attr("id", "pack_layout")
              .attr("transform", "translate(" +
                position[0] + "," +
                position[1] + ")");

            var node = g.selectAll("g")
              .data(nodes)
              .enter().append("g")
              .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; })
              //.attr("class", function(d) { return d.parent ? (d.children ? "node node--leaf": "node") : "node node--root"; })
              .style("opacity", function(d){ return d.parent ? (d.children ? 0.7 : 1.0) : 0.2; })
              .each(function(d) { d.node = this; })
              .on("click", function(d) {
                if (focus !== d) {
                  zoom(d);
                  d3.event.stopPropagation();
                }
              })
              .on("mouseover", function(d) {
                if(!d.parent) {return;}

                d3.select(this).style("stroke", "black").style("stroke-width", "1.5");
                if(d.children) {
                  highlight(map_svg, d.data.name);
                }
              })
              .on("mouseout", function(d) {
                if(!d.parent) {return;}

                d3.select(this).style("stroke", "none");
                if(d.children) {
                  cancel_highlight(map_svg);
                }

              });

            g.on("click", function() { zoom(root); });

            var circle = node.append("circle")
              .attr("r", function(d) { return d.r; })
              .attr("id", function(d) { return d.data.name; })
              .style("fill", function(d) {
                return color(d.depth);
              })
              .on("mouseover",function(d){
                if(!d.children) {
                  const point_id = "ex"+d.data.name.substring(2, d.data.name.length);
                  d3.select("circle#"+ point_id).attr("r", 5)
                    .style("fill", "white")
                    .style("stroke-width", "3");
                }
              })
              .on("mouseout", function(d) {
                if(!d.children) {
                  const point_id = "ex"+d.data.name.substring(2, d.data.name.length);
                  d3.select("circle#"+ point_id).attr("r", 3)
                    .style("fill", "red")
                    .style("stroke-width", "1");
                }
              });

            // initialize view by this call
            zoomTo([root.x, root.y, root.r * 2]);

            function zoom(d) {
              var focus0 = focus; focus = d;
              var transition = d3.transition()
                  .duration(d3.event.altKey ? 7500 : 750)
                  .tween("zoom", function(d) {
                    let margin_y = 1;

                    //var i = d3.interpolateZoom(view, [focus.x-focus.r*1.2/2, focus.y-focus.r*1.2/2+margin_y, focus.r*1.2]);
                    var i = d3.interpolateZoom(view, [focus.x, focus.y, focus.r * 2]);
                    return function(t) { zoomTo(i(t)); };
                  });
            }

            function zoomTo(v) {
              var k = diameter / v[2]; view = v;
              node.attr("transform", function(d) {
                return "translate(" + (d.x - v[0]) * k + "," + (d.y - v[1]) * k + ")";
              });
              circle.attr("r", function(d) { return d.r * k; });
            }
          }

          function hovered(hover) {
            return function(d) {
              d3.selectAll(d.ancestors().map(function(d) { return d.node; })).classed("node--hover", hover);
            };
          }

          function drawAll(data_list, positions, map_svg) {
            for(var i in data_list) {
              drawData(data_list[i], positions[i], map_svg);
            }
          }

          multiCsv(expedition_files, function (err, results) {

            let data_list = [];
            let positions = [];

            for (var [key, e_data_list] of results) {

              data_list.push(new Ocean(key, e_data_list));
              const ex_positions = e_data_list.map(data => compute_ex_position(data));

              let x_pos = 0, y_pos = 0;
              for(var i_pos in ex_positions) {
                x_pos += ex_positions[i_pos][0];
                y_pos += ex_positions[i_pos][1];
              }

              if(key === "atlantic") {
                y_pos -= 500;
                x_pos -= 550;
              }

              if(key === "indian") {
                y_pos -= 1000;
                x_pos -= 4500;
              }

              if(key === "pacific") {
                y_pos += 500;
                x_pos -= 5000;
              }

              if(key === "mediterranean") {
                y_pos += 220;
                x_pos += 200;
              }

              positions.push([x_pos/ex_positions.length, y_pos/ex_positions.length]);
            }

            let map = d3.select("#map");//.on('mousemove', mousemoved);

            let i = 1;
            results.forEach(function(data_list, ocean, mapObj) {
              data_list.forEach(function(data) {
                let expedition_id = get_expedition_id(data);
                let exists = typeof(expedition_data.get(expedition_id)) !== 'undefined';
                if(exists) {
                  expedition_id = expedition_id + i;
                  i += 1;
                }
                expedition_data.set(expedition_id, data);

                map.append("path")
                   .datum(data)
                   .attr("class", "line")
                   .attr("id", expedition_id)
                   .attr("d", line)
                   .on('mouseout', function(d) {
                     let this_path = d3.select(this);
                     let e_id = this_path.attr("id");
                     if(SELECTED_EXP_ID === e_id) {
                         cancel_highlight(map);
                     }
                     this_path.style("cursor", "default");
                   })
                   .on('mouseover', function(d){
                     let this_path = d3.select(this);
                     let e_id = this_path.attr("id");
                     highlight(map, e_id);

                     this_path.style("cursor", "pointer");
                   });

                map.append("g")
                  .selectAll("circle")
                  .data(data).enter().append("circle")
                  .attr("cx", function(d){
                    return get_coord(d, 'x');
                  })
                  .attr("cy", function(d){
                    return get_coord(d, 'y');
                  })
                  .attr("r", 3)
                  .attr("id", function(d, i){
                    return "ex_point_"+i+"_"+expedition_id;
                  })
                  .attr("fill","red")
                  .style("stroke", "white")
                  .style("stroke-width","1")
                  .on('mouseover', function(d) {
                    let this_circle = d3.select(this);
                    let e_id = this_circle.attr("id");

                    if(!e_id.includes(SELECTED_EXP_ID)) {
                      let terms = e_id.split('_');
                      let curr_e_id = terms[terms.length-1];
                      highlight(map, curr_e_id);
                    }

                    this_circle.style("cursor", "pointer");
                    this_circle.attr("r", 5).style("fill", "white");

                    const point_id = this_circle.attr("id")
                    const stat_id = "st"+point_id.substring(2, point_id.length);
                    d3.select("circle#"+ stat_id)
                      .style("stroke", "black")
                      .style("stroke-width", "1.5");
                  })
                  .on('mouseout',function (d) {
                    let this_circle = d3.select(this);
                    let e_id = this_circle.attr("id");
                    let terms = e_id.split('_');
                    let curr_e_id = terms[terms.length-1];
                    if(SELECTED_EXP_ID === curr_e_id) {
                      cancel_highlight(map);
                    }
                    this_circle.style("cursor", "default").style("fill", "red");
                    this_circle.attr("r", 3);

                    const point_id = this_circle.attr("id");
                    const stat_id = "st"+point_id.substring(2, point_id.length);
                    d3.select("circle#"+ stat_id)
                      .style("stroke", "none");
                  });
              });
            });

            drawAll(data_list, positions, map);
          });

          let allButtons= svg.append("g").attr("id","allButtons");
          let labels= ['Overview','Expeditions','Spreading'];  //here maybe some more creative way
          let defaultColor= "#7777BB"
          let hoverColor= "#0000ff"
          let pressedColor= "#000077"

          let buttonGroups= allButtons.selectAll("g.button")
                                      .data(labels).enter()
                                      .append("g")
                                      .attr("class","button")
                                      .style("cursor","pointer")
                                      .on("click",function(d,i) {
                                                 d3.select(this.parentNode).selectAll("rect").attr("fill",defaultColor)
                                            d3.select(this).select("rect").attr("fill",pressedColor).style("fill",pressedColor)
                                                  var url = 'map_'+d+'.html'
                                                  console.log(url)
                                                  // $(location).attr('href', url);
                                                  window.location.assign(url);
                                              })
                                      .on("mouseover", function() {
                                                   if (d3.select(this).select("rect").attr("fill") != pressedColor) {
                                                d3.select(this)
                                                    .select("rect")
                                                    .attr("fill",hoverColor)
                                                    .style("fill",hoverColor)
                                            }
                                              })
                                      .on("mouseout", function() {
                                                 if (d3.select(this).select("rect").attr("fill") != pressedColor) {
                                                d3.select(this)
                                                    .select("rect")
                                                    .attr("fill",defaultColor)
                                                    .style("fill",defaultColor);
                                            }
                                              });

            var bWidth= 100; //button width
            var bHeight= 25; //button height
            var bSpace= 10; //space between buttons
            var x0= 20; //x offset
            var y0= window.innerHeight*0.80+5; //y offset
            buttonGroups.append("rect")
                        .attr("class","buttonRect")
                        .attr("width",bWidth)
                        .attr("height",bHeight)
                        .attr("x",x0)
                        .attr("y",function(d,i) {return y0+(bHeight+bSpace)*i;})
                        .attr("rx",5) //rx and ry give the buttons rounded corners
                        .attr("ry",5)
                        .attr("fill",function(d,i){
                    if (i==1) return pressedColor;
                      return defaultColor})
                  .style("fill",function(d,i){
                    if (i==1) return pressedColor;
                      return defaultColor})

            buttonGroups.append("text")
                        .attr("class","buttonText")
                        .attr("font-family","FontAwesome")
                        .attr("x",x0 + bWidth/2)
                        .attr("y",function(d,i) { return y0+ (bHeight+bSpace)*i + bHeight/2; })
                        .attr("text-anchor","middle")
                        .attr("dominant-baseline","central")
                        .attr("fill","white")
                        .text(function(d) {return d;});
                    });

</script>
  </body>
</html>
